#include <math.h>
#include "progressive/float_prog_lib.h"
#include "progressive/expconsts.h"

double rlibm_prog_rno_exp(float x) {
  float_x fx;
  fx.f = x;
  
  // Take care of special cases
  if ((fx.x & 0x7FFFFFFF) == 0) return 1.0;

  if (fx.x <= 872415231) {
    if (fx.x <= 864026623) return 1.0000000298023223876953125;
    return 1.0000000894069671630859375;
  }

  if (1118925336 <= fx.x && fx.x <= 3011510272) {
    if (fx.x < 0x80000000) {
      if (fx.x < 0x7F800000) return 3.40282361850336062550457001444955389952e+38;
      if (fx.x == 0x7F800000) return 1.0 / 0.0;
      return 0.0/0.0;
    }
    
    // negative counterpart
    if (fx.x <= 3003121664) return 0.99999998509883880615234375;
    
    return 0.99999995529651641845703125;
  }

  if (fx.x >= 3268407733) {
    if (fx.x == 0xFF800000) return 0.0;
    if (fx.x < 0xFF800000) return ldexp(1.0, -151);
    return 0.0/0.0;
  }
  
  // Perform range reduction
  double xp = x * 92.332482616893656768297660164535045623779296875;
  int N = (int)xp;
  int N2 = N % 64;
  if (N2 < 0) N2 += 64;
  int N1 = N - N2;
  
  int M = N1 / 64;
  int J = N2;
  double R = x - N *
  0.01083042469624914509729318723429969395510852336883544921875;

  // Compute polynomial
  double y;
  if (R < -9.6491802992204611655324697494506835937500000000000000000000000000000000e-08) {
    if (R < -1.1406728762928253217978635802865028381347656250000000000000000000000000e-03) {
      y = 1.4556614506109601947514420317020267248153686523437500000000000000000000e+01;
      y *= R;
      y += 5.4670639533025977563340802589664235711097717285156250000000000000000000e-01;
      y *= R;
      y += 4.9511242959151123554928375369854620657861232757568359375000000000000000e-02; // tf32
      y *= R;
      y += 1.6672367226186496358408817286544945091009140014648437500000000000000000e-01; // bf16
      y *= R;
      y += 5.0000021476383516016994690289720892906188964843750000000000000000000000e-01;
      y *= R;
      y += 1.0000000003895790356978068302851170301437377929687500000000000000000000e+00;
      y *= R;
      y += 1.0000000000002577937863179613486863672733306884765625000000000000000000e+00;
    } else {
      y = 1.6662107000741135931498604350053938105702400207519531250000000000000000e-01; // tf32 //bf16
      y *= R;
      y += 5.0000000098461327979748602956533432006835937500000000000000000000000000e-01;
      y *= R;
      y += 1.0000000000079283246634531678864732384681701660156250000000000000000000e+00;
      y *= R;
      y += 1.0000000000000019984014443252817727625370025634765625000000000000000000e+00;
    }
  } else {
    if (R < 1.0469059610346276301129364583175629377365112304687500000000000000000000e-03) {
      y = 1.6681418524790977975236216934717958793044090270996093750000000000000000e-01; // tf32 //bf16
      y *= R;
      y += 4.9999988701064923546368845563847571611404418945312500000000000000000000e-01;
      y *= R;
      y += 1.0000000000239945840974087332142516970634460449218750000000000000000000e+00;
      y *= R;
      y += 9.9999999999999922284388276239042170345783233642578125000000000000000000e-01;
    } else {
      y = 4.1917355633872339926160321965653565712273120880126953125000000000000000e-02 ; // tf32
      y *= R;
      y += 1.6666396780921632903016416094033047556877136230468750000000000000000000e-01; // bf16
      y *= R;
      y += 5.0000001256951642769621457773610018193721771240234375000000000000000000e-01;
      y *= R;
      y += 9.9999999997549804398033757024677470326423645019531250000000000000000000e-01;
      y *= R;
      y += 1.0000000000000159872115546022541821002960205078125000000000000000000000e+00;
    }
  }
  
    
  // Perform output compensation
  y *= ldexp(exp2JBy64[J], M);
  return y;
}
